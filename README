Potoceanu Ana-Maria, 311CA
Tema 1, Metode Numerice

Markov is coming...
    -parse_labyrinth-

    Pentru inceput, am implementat functia parse_labyrinth care primeste ca parametru calea catre un fisier text. 
Dupa ce facem verificarea ca fisierul a fost deschis cu succes, citim din fisier dimensiunile matricei care urmeaza sa 
fie creata. Dimensiunile le vom citi de pe primul rand din fisier, mai exact: primul numar corespunde numarul de randuri, 
iar al doilea numarului de coloane.Cream o matrice plina cu zerouri. Citim urmatoarele randuri din fisier. 
Vom selecta cu ajutorul sintaxei: Labyrinth(k, :),intreaga linie din matrice, careia ii atribuim valorile citite din fisier. 
Fiecare rand din fisier este, de fapt, un rand din matricea Labyrinth. In final, inchidem fisierul.

    -get_adjacency_matrix-

    In aceasta functie, am tratat separat cazurile cand ne aflam pe prima, respectiv ultima linie si pe
prima coloana, respectiv ultima coloana. Acest lucru a fost necesar, deoarece starea de win se afla fie la nord, fie la sud, 
iar starea de lose se afla fie la est, fie la vest. Verificarile le-am facut cu ajutorul functiei bitand, ajutandu-ne de 
numerele 8, 4, 2,1.
8 -> 1000, bitul b3 este setat pe 1, indica un zid la nordul celulei
4 -> 0100, bitul b2 este setat pe 1, indica un zid la sudul celulei
2 -> 0010, bitul b1 este setat pe 1, indica un zid la estul celulei
1 -> 0001, bitul b0 este setat pe 1, indica un zid la vestul celulei
Functia intoarce astfel matricea de adiacenta.

    -get_link_matrix -

    In aceasta fuctie, ne folosim de o matrice auxiliara, care va fi matricea de adiacenta.
Unde intalnim 1 in matricea de adiacenta, vom inlocui cu probabilitatea. Probabilitatea se calculeaza 1 / suma, unde
suma este suma de pe linia corespunzatore. Sumele le-am retinut intr-un vector, pentru a ne fi mai usor.

    -get_Jacobi_parameters -

    Obtinem dimeniunile matricei de legaturi. Matricea de iteratie este asemenatoare matricei Link, doar ca nu contine
linii si coloanele corespunzatoare starilor win si lose. Vectorul de iteratie il vom selecta din matricea Link, fiind coloana
corespunzatoare starii win. De asemenea, acesta va avea dimensiunea cu 2 mai putin.

    -perform_iterative -

    In cadrul acestei functii, am folosit implementarea prezentata la laborator. Mai exact, la fiecare pas calculam x 
conform fromulei si eroarea.In cazul in care am atins numarul maxim de pasi sau daca obtinem o eroare mai mica decat 
tolerantam, ne oprim. Vom retine de fiecare data cine este prev_x si nu uitam in final sa-i modificam valoarea.

    -heuristic_greedy-

    Pentru a determina calea valida catre starea WIN, ne vom folosi de un vector coloana in care retinem care vecini 
au fost vizitati sau nu. La inceput, se considera ca toti vecinii sunt nevizitati. Calea catre starea WIN o retinem 
intr-un vector coloana, denumit path.Adugam pe prima pozitie a vectorului path pozitia de start. Algoritmul
functioneaza cat timp avem vecini care nu au fost vizitati. In cazul in care toti vecinii au fost vizitati, 
ne oprim si eliminam indexul din vector. Daca am ajuns la starea WIN, ne oprim. Daca vecinii nu au fost vizitati, 
determinam care vecin are probabilitatea mai mare de castig, conform vectorului probabilities. Se adauga vecinul 
cu cea mai mare probabilitate in vector.

    -decode_path-

    Am creat un vector care va avea doua coloane. Prima coloana este corespunzatoare indicilor pentru randuri, 
iar a doua coloana pentru coloane. Selectam pe rand din vectorul path, cate un element si ii vom calcula separat indicii.
In final adaugam perechea in vector.

Linear Regression

    -parse_data_set_file-
    
    Deschidem fisierul si citim dimeniunile matricei de pe primul rand.
Primul element de pe fiecare rand va fi adaugat in vectorul coloana Y, urmand ca celelalte elemente sa fie adaugate in matrice. 
Vom face verificarea daca sirul citit este un numar sau nu. In cazul in care este numar, ne folosim de functia str2double 
pentru a-l retine in matrice, in mod corespunzator. 

    -parse_csv_file-

    In aceasta functie primim ca parametru calea catre un fisier csv. Deschidem fisierul si citim datele cu ajutorul functiei 
textscan. Cu ajutoul acestei functiei putem sa retinem intregul rand din fisier care va fi distribuit astfel: primul element 
va fi adaugat in vectorul Y, iar celelalte elemente in InitialMatrix. Pentru a afla cate elemente avem pe o linie, ne ajutam 
de regexp, care va pune fiacare element intr-un vector. In acest fel, avem acces toate elementele de pe fiecare linie. 
Elementele in matrice le vom pune ignorand token{1}, primul numar de pe linie.

    -prepare_for_regression-

    Pentru inceput, am luat cazurile cand valoarea dintr-o celula nu este un string. In acest caz, trasformam elementul in 
numar si il adaugam in matrice. In continuare, am verificat daca avem string-urile "yes", "no". In acest caz, nu creste 
numarul de coloane al matricei. Se inlocuieste celula data cu 1 pentru string-ul "yes" si cu 0 pentru string-ul "no". 
In ultimul caz, a fost nevoie sa mutam toate elementele incepand cu pozitia j+1, deoarece se va adauga o noua coloana si 
astfel evitam sa suprascriem alte elemente. 

    -linear_regression_cost_function-

    In aceasta functie, am implementat formula data in cerinta temei. Mai exact, pentru fiecare rand din matrice se calculeza
valoarea prezisa. Aceasta va fi produsul dintre randul respectiv si vectorul coloana Theta, unde primul element se considera 0.
Se scade din valoarea prezisa iesirea corespunzatore. Rezultatul se ridica la patrat si se adauga la variabila prod.
S-a calculat eroarea conform formulei prezentate.

    - gradient_descent-

    In aceasta functie, am initializat initial vectorul Theta cu zerouri si de asemenea avem nevoie de un vector coloana
in care vom retine derivatele partiale in raport cu fiecare coeficient. Se calculeaza valoarea prezisa, mai exact, 
inmultim fiecare element de pe o linie cu coeficientul theta corespunzator. Calculam suma conform formulei prezentate 
in enunt. Se calculeaza derivata partiala pe care o retinem intr-un vector. Theta se calculeaza in functie de parametrul iter.
La fiecare pas vom scadea produsul alpha * Delta(j). In final am adaugat 0 la inceputul vectorului theta, valoarea 
corespunzatoare pentru theta 0.

    -normal_equation-
    In aceasta functie, am implementat pseudocodul pus la dispozitie in cadrul temei. 
Matricea A din algortim este de fapt FeatureMatrix'* FeatureMatrix. X este de fapt Theta, iar b se calculeaza 
FeatureMatrix' * y. Avem astfel ecuatia (FeatureMatrix'* FeatureMatrix) * Theta = FeatureMatrix' * y.
La inceput am verificat daca matricea obtinuta prin produsul FeatureMatrix' * FeatureMatrix este pozitiv definita. 
Acest lucru a fost verificat cu ajutorul functiei chol. In cazul in care matricea nu era pozitiv definita, 
returnam un vector coloana full de zero pentru Theta. Am calculat b conform formulei si am initializat vectorul x0 cu zero.
La fiecare pas am calculat termenii din pseudocod. De asemenea, am avut grija sa modificam valorea lui rprev, 
intrucat ne trebuie si cel anterior si cel actual. Algortimul se opreste atunci cand produsul dintre  rprev' * rprev este mai 
mare decat toleranta ridicata la patrat sau cand ajungem la numarul maxim de pasi.

    -lasso_regression_cost_function-

    In aceasta functie, am calculat pe rand pentru fiecare antrenament(rand), valorea prezisa din care vom scadea
ulterior iesirea corespunzatoare. Calculam norma vectorului Theta, iar in final am obtinut eroarea
conform formulei prezentate.

    - ridge_regression_cost_function-

    Am calculat primul termen din formula in acelasi mod ca mai sus. De asemenea, pentru formula de la aceasta functie am avut nevoie
de suma patratelor fiec

MNIST 101

    -load_dataset-

    Deschidem fisierul si salvam toate datele din el intr-o variabila, cu ajutorul functiei load.
Matricei X ii atribuim campul X care se gaseste in fisierul dat, iar vectorului y ii atribuim campul corespunzator.

    -split_dataset-

    Vom genera o ordine random pentru randurile din matrice, folosind functia randperm. Retinem matricea si vectorul care
contin liniile interschimbate. Calculam numarul de linii care va fi adaugat in X_train, respectiv in y_train.
Primele per linii se vor pune in X_train, iar celelalte vor fi adugate in X_test, de asemenea la fel se procedeaza si pentru y_test si pentru y_train.

    -initialize_weights-

    Calculam cu ajutorul formulei prezente numarul e. Vom genera o matrice cu elemente aleatorii care se afla in intervalul
(-e, e). Acest lucru l-am implementat cu ajutorul functiei rand.








